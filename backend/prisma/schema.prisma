generator client {
  provider               = "prisma-client"
  output                 = "../src/generated/prisma"
  runtime                = "nodejs"
  moduleFormat           = "esm"
  generatedFileExtension = "ts"
  importFileExtension    = "ts"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            Int                      @id @default(autoincrement())
  createdAt     DateTime                 @default(now())
  updatedAt     DateTime                 @updatedAt
  email         String?                  @unique
  name          String?
  ciLogonUserId String?                  @unique
  orgs          OrganizationMembership[]

  /**
   * A temporary random value that we store to ensure OAuth URLs were created by us (CSRF prevention).
   * When creating the URL, we store the state here, and when GitHub redirects back to us, we check it
   * with the copy in the DB. If they match, the authorization request was initiated by us. Note that
   * this doesn't mean the URL wasn't tampered with; we have to verify other parameters separately.
   */
  githubOAuthState String?
}

model OrganizationMembership {
  userId          Int
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  organizationId  Int
  organization    Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  permissionLevel PermissionLevel

  @@id([userId, organizationId])
}

enum PermissionLevel {
  OWNER
  USER
}

model Organization {
  id                   Int                      @id @default(autoincrement())
  createdAt            DateTime                 @default(now())
  updatedAt            DateTime                 @updatedAt
  name                 String
  users                OrganizationMembership[]
  apps                 App[]
  githubInstallationId Int?

  /**
   * Temporary storage for an Installation ID that hasn't been verified to be accessible by the user who set it. See src/handlers/githubAppInstall.ts for more info on the installation/authorization process.
   */
  newInstallationId Int?
}

enum ImageBuilder {
  dockerfile
  railpack
}

model App {
  id               Int          @id @default(autoincrement())
  orgId            Int
  org              Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
  name             String
  displayName      String
  repositoryId     Int
  repositoryBranch String       @default("main")
  subdomain        String       @unique
  imageRepo        String       @default("")
  deployments      Deployment[]
  logIngestSecret  String       @unique
}

model Deployment {
  id            Int              @id @default(autoincrement())
  appId         Int
  app           App              @relation(fields: [appId], references: [id], onDelete: Cascade)
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  commitHash    String?
  commitMessage String?
  builderJobId  String?
  checkRunId    Int?
  imageTag      String?
  status        DeploymentStatus @default(PENDING)
  // A random value used by the builder (in place of the deployment ID) to make changes to this Deployment.
  // API clients should only be able to update deployments if they have the deployment's secret or some other form of authorization.
  secret        String?          @unique
  config        DeploymentConfig @relation(fields: [configId], references: [id])
  configId      Int              @unique
  storageConfig StorageConfig?
  logs          Log[]
}

model DeploymentConfig {
  id             Int          @id @default(autoincrement())
  builder        ImageBuilder
  rootDir        String
  dockerfilePath String?
  port           Int
  env            Json         @default("[]")
  secrets        String?
  replicas       Int          @default(1)
  deployment     Deployment?
}

model StorageConfig {
  id         Int        @id @default(autoincrement())
  image      String
  replicas   Int
  amount     Int
  port       Int
  mountPath  String
  env        Json       @default("[]")
  deployment Deployment @relation(fields: [deployId], references: [id], onDelete: Cascade)
  deployId   Int        @unique
}

model Log {
  id           Int        @id @default(autoincrement())
  createdAt    DateTime   @default(now())
  type         LogType
  deploymentId Int
  deployment   Deployment @relation(fields: [deploymentId], references: [id], onDelete: Cascade)
  timestamp    DateTime
  index        Int        @default(0) // Used to order logs with the same timestamp
  content      Json
}

enum LogType {
  // System logs created by the AnvilOps backend
  SYSTEM
  // Logs from users' image builds
  BUILD
  // Logs from users' pods
  RUNTIME
}

enum DeploymentStatus {
  // Creating and starting the build job
  PENDING
  // Building the image and pushing it to the registry
  BUILDING
  // Applying the update to the cluster
  DEPLOYING
  // All resources have been updated
  COMPLETE
  // There was a problem somewhere during the process
  ERROR
  // Deployment is no longer active
  STOPPED
}

model Session {
  sid    String   @id @db.VarChar
  sess   Json     @db.Json
  expire DateTime @db.Timestamp(6)

  @@index([expire], name: "IDX_session_expire")
  @@map("session")
}
