generator client {
  provider               = "prisma-client"
  output                 = "../src/generated/prisma"
  runtime                = "nodejs"
  moduleFormat           = "esm"
  generatedFileExtension = "ts"
  importFileExtension    = "ts"
}

generator json {
  provider  = "prisma-json-types-generator"
  namespace = "PrismaJson"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            Int                      @id @default(autoincrement())
  createdAt     DateTime                 @default(now())
  updatedAt     DateTime                 @updatedAt
  email         String?                  @unique
  name          String?
  ciLogonUserId String?                  @unique
  orgs          OrganizationMembership[]

  /**
   * A temporary random value that we store to ensure OAuth URLs were created by us (CSRF prevention).
   * When creating the URL, we store the state here, and when GitHub redirects back to us, we check it
   * with the copy in the DB. If they match, the authorization request was initiated by us. Note that
   * this doesn't mean the URL wasn't tampered with; we have to verify other parameters separately.
   */
  githubOAuthState String?

  // (ignore this - reverse relation is never used)
  repoImportState RepoImportState[]
}

model OrganizationMembership {
  userId          Int
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  organizationId  Int
  organization    Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  permissionLevel PermissionLevel

  @@id([userId, organizationId])
}

enum PermissionLevel {
  OWNER
  USER
}

model Organization {
  id                   Int                      @id @default(autoincrement())
  createdAt            DateTime                 @default(now())
  updatedAt            DateTime                 @updatedAt
  name                 String
  users                OrganizationMembership[]
  apps                 App[]
  githubInstallationId Int?

  /**
   * Temporary storage for an Installation ID that hasn't been verified to be accessible by the user who set it. See src/handlers/githubAppInstall.ts for more info on the installation/authorization process.
   */
  newInstallationId Int?

  // (ignore this - reverse relation is never used)
  repoImportState RepoImportState[]

  appGroups AppGroup[]
}

enum ImageBuilder {
  dockerfile
  railpack
}

enum DeploymentSource {
  GIT
  IMAGE
}

model App {
  id                         Int              @id @default(autoincrement())
  orgId                      Int
  org                        Organization     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  appGroupId                 Int
  appGroup                   AppGroup         @relation(fields: [appGroupId], references: [id], onDelete: Cascade)
  createdAt                  DateTime         @default(now())
  updatedAt                  DateTime         @updatedAt
  name                       String
  displayName                String
  subdomain                  String           @unique
  imageRepo                  String           @default("")
  deployments                Deployment[]
  logIngestSecret            String           @unique
  // The config to use when creating a new deployment
  deploymentConfigTemplate   DeploymentConfig @relation(fields: [deploymentConfigTemplateId], references: [id], onDelete: Cascade)
  deploymentConfigTemplateId Int              @unique
}

model AppGroup {
  id    Int          @id @default(autoincrement())
  orgId Int
  org   Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  name  String
  apps  App[]

  // Organization cannot have app groups of the same name
  @@unique([orgId, name])
}

model Deployment {
  id            Int              @id @default(autoincrement())
  appId         Int
  app           App              @relation(fields: [appId], references: [id], onDelete: Cascade)
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  commitHash    String?
  commitMessage String?
  builderJobId  String?
  checkRunId    Int?
  status        DeploymentStatus @default(PENDING)
  // A random value used by the builder (in place of the deployment ID) to make changes to this Deployment.
  // API clients should only be able to update deployments if they have the deployment's secret or some other form of authorization.
  secret        String?          @unique
  config        DeploymentConfig @relation(fields: [configId], references: [id], onDelete: Cascade)
  configId      Int              @unique
  logs          Log[]
}

model DeploymentConfig {
  id             Int              @id @default(autoincrement())
  // Deployment options
  port           Int
  /// [EnvVar[]]
  env            Json             @default("[]")
  envKey         String           @default("")
  replicas       Int              @default(1)
  deployment     Deployment?
  mounts         MountConfig[]
  // Build options
  source         DeploymentSource
  // > Git deployment source
  repositoryId   Int?
  branch         String?          @default("main")
  builder        ImageBuilder?
  rootDir        String?
  dockerfilePath String?
  // > Image deployment source
  imageTag       String?

  // Reverse relation field for when this DeploymentConfig is an App's template config
  app App?
}

model MountConfig {
  id                 Int              @id @default(autoincrement())
  path               String
  amountInMiB        Int
  deploymentConfig   DeploymentConfig @relation(fields: [deploymentConfigId], references: [id], onDelete: Cascade)
  deploymentConfigId Int
}

model Log {
  id           Int        @id @default(autoincrement())
  createdAt    DateTime   @default(now())
  type         LogType
  deploymentId Int
  deployment   Deployment @relation(fields: [deploymentId], references: [id], onDelete: Cascade)
  timestamp    DateTime
  index        Int        @default(0) // Used to order logs with the same timestamp
  content      Json
}

// A temporary object used to keep track of state while going through the GitHub OAuth flow
// We need to do this because creating a repository on a user account requires a user access token, so we have to get one, which requires a redirect to GitHub and then back to us.
model RepoImportState {
  id            String       @id @default(uuid())
  createdAt     DateTime     @default(now())
  srcRepoURL    String
  destIsOrg     Boolean
  destRepoOwner String
  destRepoName  String
  makePrivate   Boolean
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        Int
  org           Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId         Int
}

enum LogType {
  // System logs created by the AnvilOps backend
  SYSTEM
  // Logs from users' image builds
  BUILD
  // Logs from users' pods
  RUNTIME
}

enum DeploymentStatus {
  // Creating and starting the build job
  PENDING
  // Building the image and pushing it to the registry
  BUILDING
  // Applying the update to the cluster
  DEPLOYING
  // All resources have been updated
  COMPLETE
  // There was a problem somewhere during the process
  ERROR
  // Deployment is no longer active
  STOPPED
}

model Session {
  sid    String   @id @db.VarChar
  sess   Json     @db.Json
  expire DateTime @db.Timestamp(6)

  @@index([expire], name: "IDX_session_expire")
  @@map("session")
}
