generator client {
  provider               = "prisma-client"
  output                 = "../src/generated/prisma"
  runtime                = "nodejs"
  moduleFormat           = "esm"
  generatedFileExtension = "ts"
  importFileExtension    = "ts"
  previewFeatures        = ["driverAdapters", "queryCompiler"]
}

generator json {
  provider  = "prisma-json-types-generator"
  namespace = "PrismaJson"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              Int                      @id @default(autoincrement())
  createdAt       DateTime                 @default(now())
  updatedAt       DateTime                 @updatedAt
  email           String?                  @unique
  name            String?
  ciLogonUserId   String?                  @unique
  clusterUsername String?                  @unique
  orgs            OrganizationMembership[]

  /**
   * A temporary random value that we store to ensure OAuth URLs were created by us (CSRF prevention).
   * When creating the URL, we store the state here, and when GitHub redirects back to us, we check it
   * with the copy in the DB. If they match, the authorization request was initiated by us. Note that
   * this doesn't mean the URL wasn't tampered with; we have to verify other parameters separately.
   */
  githubOAuthState GitHubOAuthState?

  /**
   * These fields are used to save GitHub App installations that have been approved in the background by an organization owner.
   * When a user requests an app to be installed, GitHub redirects back to us with no information about an installation ID, so
   * we need to wait for a webhook payload that's triggered when the installation is complete. Then, we need to give the user the
   * ability to choose which organization the installation should be added to, because GitHub doesn't give us any way to save some
   * state in the request.
   */
  githubUserId            Int?
  unassignedInstallations UnassignedInstallation[]

  // (ignore this - reverse relation is never used)
  repoImportState RepoImportState[]

  receivedInvitations Invitation[] @relation(name: "invitationInvitee")
  sentInvitations     Invitation[] @relation(name: "invitationInviter")
}

model GitHubOAuthState {
  id     Int               @id @default(autoincrement())
  random String            @unique
  user   User              @relation(fields: [userId], references: [id])
  userId Int               @unique
  orgId  Int
  action GitHubOAuthAction
}

enum GitHubOAuthAction {
  // Used when the user starts installing the Github App (on the initial redirect to github.com/.../installations/new)
  CREATE_INSTALLATION
  // Used when the user requested approval to install the GitHub App and we need to get their username to associate the request with them
  GET_UID_FOR_LATER_INSTALLATION
  // Used when the user supplies an installation ID in a URL parameter and we need to verify that the user has access to it 
  VERIFY_INSTALLATION_ACCESS
}

model UnassignedInstallation {
  id             Int    @id @default(autoincrement())
  user           User   @relation(fields: [userId], references: [id])
  userId         Int
  installationId Int
  // The user name or organization name
  targetName     String
  // The URL to view the installation & allowed repositories
  url            String
}

model OrganizationMembership {
  userId          Int
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  organizationId  Int
  organization    Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  permissionLevel PermissionLevel

  @@id([userId, organizationId])
}

enum PermissionLevel {
  OWNER
  USER
}

model Organization {
  id                   Int                      @id @default(autoincrement())
  createdAt            DateTime                 @default(now())
  updatedAt            DateTime                 @updatedAt
  name                 String
  users                OrganizationMembership[]
  apps                 App[]
  githubInstallationId Int?

  /**
   * Temporary storage for an Installation ID that hasn't been verified to be accessible by the user who set it. See src/handlers/githubAppInstall.ts for more info on the installation/authorization process.
   */
  newInstallationId Int?

  // (ignore this - reverse relation is never used)
  repoImportState RepoImportState[]

  appGroups AppGroup[]

  outgoingInvitations Invitation[]
}

model Invitation {
  id        Int          @id @default(autoincrement())
  createdAt DateTime     @default(now())
  inviterId Int
  inviter   User         @relation(name: "invitationInviter", fields: [inviterId], references: [id], onDelete: Cascade)
  inviteeId Int
  invitee   User         @relation(name: "invitationInvitee", fields: [inviteeId], references: [id], onDelete: Cascade)
  orgId     Int
  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([inviteeId, orgId])
}

enum ImageBuilder {
  dockerfile
  railpack
}

enum DeploymentSource {
  GIT
  IMAGE
}

model App {
  id              Int               @id @default(autoincrement())
  orgId           Int
  org             Organization      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  appGroupId      Int
  appGroup        AppGroup          @relation(fields: [appGroupId], references: [id], onDelete: Cascade)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  name            String
  displayName     String
  namespace       String            @unique
  imageRepo       String            @default("")
  deployments     Deployment[]
  logIngestSecret String            @unique
  // The config to use when creating a new deployment
  config          DeploymentConfig? @relation(fields: [configId], references: [id])
  configId        Int?              @unique

  // A Rancher user id to use when updating the app during CD
  clusterUsername String?
  // Project ID the apps are part of (used in Rancher-managed clusters)
  projectId       String?
  enableCD        Boolean @default(true)
}

model AppGroup {
  id     Int          @id @default(autoincrement())
  orgId  Int
  org    Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  name   String
  // Is monolith app and should be displayed to the user as a single app not part of a group.
  isMono Boolean      @default(false)
  apps   App[]
}

model Deployment {
  id            Int      @id @default(autoincrement())
  appId         Int
  app           App      @relation(fields: [appId], references: [id], onDelete: Cascade)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  commitMessage String?
  builderJobId  String?
  checkRunId    Int?

  // Used to update a deployment when the correct workflow run finishes
  workflowRunId Int?             @unique
  status        DeploymentStatus @default(PENDING)
  // A random value used by the builder (in place of the deployment ID) to make changes to this Deployment.
  // API clients should only be able to update deployments if they have the deployment's secret or some other form of authorization.
  secret        String?          @unique
  config        DeploymentConfig @relation(fields: [configId], references: [id], onDelete: Cascade)
  configId      Int              @unique
  logs          Log[]
}

model DeploymentConfig {
  id             Int              @id @default(autoincrement())
  // Deployment options
  /// [EnvVar[]]
  env            Json             @default("[]")
  envKey         String           @default("")
  deployment     Deployment?
  // Build options
  source         DeploymentSource
  // > Git deployment source
  repositoryId   Int?
  branch         String?          @default("main")
  event          WebhookEvent?
  // e.g. workflow ID
  eventId        Int?
  commitHash     String?
  builder        ImageBuilder?
  rootDir        String?
  dockerfilePath String?
  // > Image deployment source
  imageTag       String?

  collectLogs   Boolean @default(true)
  createIngress Boolean @default(true)
  subdomain     String?

  replicas Int @default(1)
  port     Int

  ///[VolumeMount[]]              
  mounts Json @default("[]")

  ///[Resources]
  limits   Json
  ///[Resources]
  requests Json

  // Reverse relation field for when this DeploymentConfig is an App's template config
  app App?
}

model Log {
  id           Int        @id @default(autoincrement())
  createdAt    DateTime   @default(now())
  type         LogType
  deploymentId Int
  deployment   Deployment @relation(fields: [deploymentId], references: [id], onDelete: Cascade)
  timestamp    DateTime
  index        Int        @default(0) // Used to order logs with the same timestamp
  content      String
  podName      String?
  stream       LogStream
}

// A temporary object used to keep track of state while going through the GitHub OAuth flow
// We need to do this because creating a repository on a user account requires a user access token, so we have to get one, which requires a redirect to GitHub and then back to us.
model RepoImportState {
  id            String       @id @default(uuid())
  createdAt     DateTime     @default(now())
  srcRepoURL    String
  destIsOrg     Boolean
  destRepoOwner String
  destRepoName  String
  makePrivate   Boolean
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        Int
  org           Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId         Int
}

// Used to cache things like GitHub API responses so that we don't have to fetch them every time.
// This reduces load on the upstream and makes the site faster.
model Cache {
  key       String   @id
  value     String
  expiresAt DateTime
}

enum WebhookEvent {
  // GitHub webhook events to deploy on
  push
  workflow_run
}

enum LogStream {
  stdout
  stderr
}

enum LogType {
  // System logs created by the AnvilOps backend
  SYSTEM
  // Logs from users' image builds
  BUILD
  // Logs from users' pods
  RUNTIME
}

enum DeploymentStatus {
  // Build job is waiting in the queue
  QUEUED
  // Creating and starting the build job
  PENDING
  // Building the image and pushing it to the registry
  BUILDING
  // Applying the update to the cluster
  DEPLOYING
  // All resources have been updated
  COMPLETE
  // There was a problem somewhere during the process
  ERROR
  // Deployment is no longer active
  STOPPED
}

model Session {
  sid    String   @id @db.VarChar
  sess   Json     @db.Json
  expire DateTime @db.Timestamp(6)

  @@index([expire], name: "IDX_session_expire")
  @@map("session")
}
